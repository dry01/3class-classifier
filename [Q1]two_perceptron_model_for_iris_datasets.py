# -*- coding: utf-8 -*-
"""two perceptron model for iris datasets

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fGwTIytNLYTInu6-BHUSwoYcuCDiMFiF

```
Dharamvir yadav(MT19CPS012)
3class classifier using two perceptron(on IRIS datasets)

```
"""



from sklearn import datasets

iris = datasets.load_iris()

for fn in iris.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(iris[fn])))

# iris datasets
iris_data = iris.data
iris_target = iris.target

import numpy as np

# model
def model(x):
  return np.matmul(x,w.transpose()) + b

#sigmoid function
def sigmoid(x):
    return (1 / (1 + np.exp(-x)))

q = [ ]
for i in iris_target:
  if i < 2:
    q.append(i)

  else:
    q.append(i -1 )
iris_target1 = np.array(q)

print(type(iris_target1))

#loss function (mse)
def mse(t1,t2):
  diff = t1- t2
  
  return np.sum(diff*diff)/ len(diff)

iris_target1 = np.reshape(iris_target1 , newshape=(150,1))

import numpy as np

q = [ ]
for i in iris_target:
  if i == 1:
    q.append(i-1)

  else:
    q.append(1)
iris_target2 = np.array(q)

print(iris_target2)

iris_target2 = np.reshape(iris_target2 , newshape=(150,1))

# initialise w and b
from numpy import random

w = random.rand(1, 4)

b = np.ones(1)

print(b)
print(w)

# traning for first perceptron

learning_rate = 0.0005
num_epochs = 50
losses = []
def fit(num_epochs, model,learning_rate,w):
    
    # Repeat for given number of epochs
    for epoch in range(num_epochs):
        
        epoch_loss = 0
        preds = model(iris_data)

        final_preds = sigmoid(preds)

        loss = mse(final_preds,iris_target1)
        epoch_loss += loss.item()

        e = iris_data.T.dot(iris_target1-final_preds)

        w += (e * learning_rate).T
    
        epoch_loss /= len(iris_data)
        losses.append(epoch_loss)
        print(w)

         

        
            
            
        # Print the progress
        if (epoch+1) % 1 == 0:
            print('Epoch [{}/{}], Loss: {:.4f}'.format(epoch+1, num_epochs, loss.item()))

fit(100,model,learning_rate,w)

import matplotlib.pyplot as plt

w1 = w
print(w)

#plot for first perceptron losses
plt.plot(losses)

from numpy import random

w = random.rand(1, 4)
#b = random.rand(1)
b = np.ones(1)

print(b)
print(w)

#training for second perceptron

learning_rate = 0.0005
num_epochs = 50
pridiction = []
losses1 = []
def fit1(num_epochs, model,learning_rate,w):
    
    # Repeat for given number of epochs
    for epoch in range(num_epochs):
        
        epoch_loss = 0
        preds = model(iris_data)

        final_preds = sigmoid(preds)

        #pridiction.append(final)

        loss = mse(final_preds,iris_target2)
        epoch_loss += loss.item()

        e = iris_data.T.dot(iris_target2-final_preds)

        w += (e * learning_rate).T
    
        epoch_loss /= len(iris_data)
        losses1.append(epoch_loss)
        print(w)

         

        
            
            
        # Print the progress
        if (epoch+1) % 1 == 0:
            print('Epoch [{}/{}], Loss: {:.4f}'.format(epoch+1, num_epochs, loss.item()))

fit1(100,model,learning_rate,w)



w2 = w
print(w)

#losses plot for second perceptron
plt.plot(losses1)

#predict the classes on data using above two perceptron training result
final_pridict = []
p2_n = []
p1_n = []
for i in range(len(iris_data)):
  p1 = np.dot(iris_data[i],w1.T)
  p1 = sigmoid(p1)
  p1_n.append(p1)
  p2 = np.dot(iris_data[i],w2.T)
  p2 = sigmoid(p2)
  p2_n.append(p2)

  if p1 <= 0.3:
    final_pridict.append(0)
  elif p2 <= 0.4:
    
    final_pridict.append(1)
  else:
    final_pridict.append(2)

final_pridict = np.array(final_pridict)

correct = 0 
for i in range(len(iris_target)):

  if (final_pridict[i] == iris_target[i]):
    correct += 1
accuracy = correct / len(iris_target)
print(accuracy)

